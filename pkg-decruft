#!/usr/bin/env ruby
# frozen_string_literal: true

require 'open3'

PREFIX = ENV.fetch('PREFIX', '/usr/local')
CONCURRENCY = ENV.fetch('CONCURRENCY', 16).to_i.clamp(1, 32)

trap(:INT) do
  puts "Interrupt"
  exit! 2
end

Thread.abort_on_exception = true

class Concurrently
  def initialize(threads: 2, &job)
    @job = job
    @threads = Integer(threads)
  end

  def each(input)
    return enum_for(:each, input) unless block_given?

    inq = SizedQueue.new(@threads * 4)
    outq = SizedQueue.new(@threads * 4)

    pool = @threads.times.map do
      Thread.new do
        begin
          while (work = inq.deq)
            outq.enq @job.call(work)
          end
        ensure
          outq.enq Thread.current
        end
      end
    end

    ingest = Thread.new do
      input.each { |i| inq.enq i }
      inq.close
    end

    until pool.empty?
      case (res = outq.deq)
      when Thread then pool.delete(res).join
      else yield res
      end
    end

    ingest.join
  end
end

module Ldd
  Lib = Struct.new(:name, :path)
  NOT_FOUND = Class.new

  def self.libs(bins)
    out, _err, status = Open3.capture3('/usr/bin/ldd', '-f', '%A %o %p\n', *bins)

    out.lines
      .map { |line| line.chomp.split(" ", 3) }
      .group_by(&:first)
      .transform_values do |v|
        v.map do |_exe, lib, path|
          Lib.new(lib, path == 'not found' ? NOT_FOUND : File.absolute_path(path))
        end
    end
  end
end

module Pkg
  def self.pkg(*args)
    out, err, status = Open3.capture3('/usr/sbin/pkg', *args)
    raise "pkg exited #{status}, stderr: #{err}" unless status.success?
    out
  end

  def self.remote_packages
    pkg('rquery', '%n').split
  end

  def self.local_packages
    pkg('query', '%n').split
  end

  def self.pkg_plist(which = '-a')
    out = pkg('info', '-l', *which)
    pkg_to_plist = {}

    out.split(/^(?=\S)/).each do |pkg_files|
      pkg, files = pkg_files.split(":", 2)

      pkg_to_plist[pkg] = files.split("\n\t").map(&:strip).reject(&:empty?)
    end

    pkg_to_plist
  end

  def self.defunct_packages
    local_packages - remote_packages
  end
end

module Commands
  def self.help
    puts " #{$0} #{[self.methods(false).join(', ')]}

defunct:

  List local packages that are not available from remote repositories.

unpackaged:

  List files in PREFIX that are not provided by any installed package.

libcheck:

  Check for packaged files that link against unpackaged, compat, or obsolete
  libraries."
  end

  def self.defunct
    puts Pkg.defunct_packages
  end

  def self.unpackaged
    require 'find'

    pkg_files = Concurrently.new(threads: CONCURRENCY) do |pkgs|
      Pkg.pkg_plist(pkgs)
    end.each(Pkg.local_packages.each_slice(32)).reduce({}, :merge)

    file_to_pkg = {}
    pkg_files.each do |pkg, files|
      files.each do |file|
        file_to_pkg[file] = pkg
      end
    end

    ignore = %w(www/* poudriere/* varnish/*).map{|pat| File.join(PREFIX, pat) }

    Find.find(PREFIX) do |f|
      if ignore.any? { |ign| File.fnmatch(ign, f) }
        Find.prune
      elsif File.file?(f) && !file_to_pkg[f]
        puts f
      end
    end
  end

  def self.libcheck
    pkg_files = Concurrently.new(threads: CONCURRENCY) do |pkgs|
      Pkg.pkg_plist(pkgs)
    end.each(Pkg.local_packages.each_slice(32)).reduce({}, :merge)

    file_to_pkg = {}
    pkg_files.each do |pkg, files|
      files.each do |file|
        file_to_pkg[file] = pkg
      end
    end

    pkg_libs = Hash.new {|h,k| h[k] = [] }
    file_to_pkg.each do |f, pkg|
      if f =~ /\.so(\.\d+)*/
        pkg_libs[File.basename(f)] << [pkg, f]
      end
    end

    defunct = Pkg.defunct_packages
    Concurrently.new(threads: CONCURRENCY) do |exes|
      Ldd.libs(exes)
    end.each(file_to_pkg.keys.each_slice(16)) do |batch|
      batch.each do |exe, libs|
        pkg = file_to_pkg[exe]

        libs.each do |lib|
          if lib.path == Ldd::NOT_FOUND
            if (src = pkg_libs.fetch(lib.name, false))
              # if the lib is in this package, assume all is well
              unless src.any? { |spkg, path| spkg == pkg }
                puts "#{pkg}: #{exe} private library #{lib.name} => #{src.map{|s| s.join(' => ')}.join(', ')}?"
              end
            else
              puts "#{pkg}: #{exe} missing library #{lib.name}"
            end
          elsif lib.path.include?("compat/") && file_to_pkg[lib.path] != pkg
            puts "#{pkg}: #{exe} using compat library #{lib.path}"
          elsif lib.path.start_with?(PREFIX) && !file_to_pkg.key?(lib.path)
            puts "#{pkg}: #{exe} using unpackaged library #{lib.path}"
          elsif defunct.include?(file_to_pkg[lib.path])
            puts "#{pkg}: #{exe} using defunct packaged library #{lib.path} from #{file_to_pkg[lib.path]}"
          end
        end
      end
    end
  end
end

if $0 == __FILE__
  commands = Commands.methods(false)
  if ARGV.size == 1 && commands.include?(ARGV.first.to_sym)
    Commands.send(ARGV.first.to_sym)
  else
    Commands.help
    exit 1
  end
end
